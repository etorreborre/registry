# Typeclasses

It is possible to create the typeclass corresponding to a given record of functions with a bit of Template Haskell:

```haskell
{-# LANGUAGE TemplateHaskell #-}

module Test.Data.Registry.THSpec where

-- IMPORTANT! You have to import the Typed module from generic-lens because
-- the typeclass instance generated by makeTypeclass needs it
import Data.Generics.Product.Typed
import Data.Registry.TH
import Protolude

data Logger m = Logger {
  -- a function taking 2 arguments
  _info  :: Text -> Text -> m ()
  -- a function having a constraint
, _error :: forall a . (Monoid a) => a -> Text -> m ()
}

makeTypeclass ''Logger
```
This generates the following code
```haskell
class WithLogger m where
  info  :: Text -> Text -> m ()
  error :: forall a . (Monoid a) => a -> Text -> m ()

instance (HasType (Logger m) s) => WithLogger (ReaderT s m) where
  info t1 t2 = ReaderT (\s -> _info (getTyped s) t1 t2)
  error a t  = ReaderT (\s -> _error (getTyped s) a t)
```

## Use typeclasses to implement components

You are advised to use the recommendation in [boilerplate](./doc/boilerplate.md) to implement your components and totally avoid parameter passing. You can however use typeclasses if you want to extract auxiliary functions and limit parameter passing.

For example you can now use the `WithLogger` typeclass instead of using a `Logger` directly. For example, let's specify another component, `Tracer` and a `Service` using both a `Logger` and a `Tracer`
```haskell
newtype Tracer m = Tracer {
  _traceIt :: Text -> m ()
}

makeTypeclass ''Tracer

newtype Service m = Service {
  doIt :: Int -> Text -> m ()
}

newService :: Monad m => Logger m -> Tracer m -> Service m
newService logger tracer = Service {
  doIt = <something here> implementService
}

-- | Implement the service using typeclasses
implementService ::
     Monad m
  => WithLogger m
  => WithTracer m
  => Int
  -> Text
  -> m ()
implementService n t = do
  info "doing it" t
  traceIt (show n)
```

As you can see we don't need to pass `logger` or `tracer` to `implementService` in order to use their functions. Nice!
However we still have to fill a blank `<something here>`. Indeed we need to find a monad which is implementing both `WithLogger m` and `WithTracer m`.

## With a bit of help from `generic-lens`

The solution is given by the `ReaderT` instance which is also generated by `makeTypeclass`. This instance uses a typeclass from `generic-lens`, `HasType c s`, describing that we can extract a component of type `c` from something of type `s`. For example from a tuple containing all our components:
```haskell
newService :: Monad m => Logger m -> Tracer m -> Service m
newService logger tracer = Service {
  -- or doIt = run ... implementService using Universum (...) operator
  doIt n t = run $ implementService n t
} where
    run = flip runReaderT (logger, tracer)
```

With this approach we can write most of our code with typeclass definitions for the functions we want use while using some concrete components for the wiring.

## Generation options

The `makeTypeclass` function uses some conventions to create the typeclass associated to a given component:

 - the name of the typeclass is `With<ComponentName>`
 - the names of the typeclass functions are the names of the component functions minus their first character. So if you prefix them with `_` as the example above you will get "nice" function names in your typeclass

You can change those 2 defaults by using the `makeTypeclassWith` function and passing a custom `TypeclassOptions` value
```haskell
makeTypeclassWith (TypeClassOptions {
  _typeclassName t = "Has" <> t
, _functionName t  = dropPrefix t
})
```
